
Long Term TODO.

Compare the deformation which results from geometry change to element deletion.

Build a good debugging setup for making calls into the Abaqus API....

Resolve the fact that if the initial residual stress field is far from equilibrium,
  then building the post-cut geometry and allowing relaxation is not equivalent
  to allowing relaxation and then doing material removal. SEE ASSUMPTION LIST
  FOR THIS!

It also feels brittle to intermingle the stress equilibration and the machining
  procedures. That is, material removal is really unrelated to a sometimes
  necessary stress equilibration step. Stress equilibration is sometimes necessary
  because the way that a stress field is represented doesn't exactly match
  reality. Material removal is a fundamental procedure which is required during
  the machining process.

Figure out a way to make the naming cleaner. Specifically, we expect some names to
  be present and we always pick some particular names for use. Also, try to make
  some of my variable names in simulation.py more concise. The names currently
  make my eyes bleed.
    Partially done. Still don't like some of name passing is done in simulation.py. 

Get the MyPy static analysis up and running. Note that, for now, I'm only attempting
  to do static analysis when Python-native types are involved. There are objects
  native to Abaqus, numpy, etc. being passed around for which no type checking is
  done. I think there is hope of getting static analysis running for at least libraries
  like numpy. It might be worthwhile to build/contribute some basic stub files
  for Abaqus.

Fix the way that imports are done so that main.py can be invoked from directories
  other than /software/ and without using its full path name.

Use cleaner technique to deal with opening and closing an mdb. Figure out how to
  deal with exceptional conditions when an MDB is open and needs to be closed.
  Using a "with" statement might be very useful to do this.

Think about Prof. Dick's claim: We need only a single BC constraining an element
  in order to prvent numerial errors from resulting in non-physical deformations.
  I agree with the claim. If the constrained element does not deform, then there
  is a slight amount of error introduced. This error is small if the element/region
  is small. If we restrict ourselves to situations where the clamps do not prevent
  the deformations due to residual stress, then I believe that the only purpose of
  boundary conditions is to prevent non-physical deformations due to numerical
  error. Therefore, constraining a single element is sufficient.

Deal with possibility that a tool path doesn't intersect the part geometry. If this
  is the case, the PartFromBooleanCut() method will throw an exception.

Make meshing more robust. Currently we just try some parameters (seed density,
  mesh shape, etc.) and if those parameters don't work we try some other
  parameters.

There is an awful lot of runtime spent mapping an orphan mesh to a new geometry.
  If we could instead chain simulations together within a single model, this could
  be avoided. To do this, it's necessary to somehow delete part regions/elements
  which live a prespecified locations in space across different steps in a simulation.
  For example, in step 1 we would want the elements that live in a particular
  region of space to be deactivated, some deformation would occur, in step 2 we 
  would want the elements that live in some other region of space to be deactivated,
  etc. 
Potential element deletion techniques: 
    1) Contact interaction / damage model. 
    2) Simulation restart with new model change.
    3) Abaqus' Additive Manufacturing Process Simulation toolset (See Analysis 
       > Analysis Techniques > Additive Manufacturing Process Simulation, also 
       see User Subroutines > Toolpath-Mesh Intersection Utility Routines, and 
       see Analysis > Analysis Techniques > Special Purpose Techniques > Progressive 
       Element Activation. The most promising approach embedded in all of this 
       is to use Progressive Element Activation to do element DEactivation at 
       across multiple steps. We could define all elements in an initial mesh 
       as eligible for element deactivation and then, in the user subroutine 
       UEPACTIVATIONVOL, find all the elements in a particular tool path (this 
       might involve querying all elements), and setting their material volume
       fractions to 0). 
    4) Approximating element removal by making the element elasticity modulus 
       very small (this was Jan's suggestion, it doesn't fully make sense to me).
Also might be possible to speed things up by using my current approach but
  doing things outside of Abaqus.

Should the internal representations of the geometric objects depend on external
  libraries? If so, we can use numpy arrays for everything.
Where it makes sense, I should override operators for my own classes. This is
  particularly evident for geometric user-defined types: I should support
  directly adding vectors, points, etc.

I've decided that all calls into the Abaqus API should be located in the
  abaqus_shim.py file. However, many of these functions return Abaqus-native
  objects, which are passed around in functions outside of abaqus_shim.py. Is
  this clean? Is the restriction of making Abaqus API calls in abaqus_shim.py
  really necessary?
    Solution: Eliminate the simple getter functions? 

Many functions in abaqus_shim.py should work with either a part or an Assembly.
  In general, having function names with '_in_assembly' is overly specific.
  Write the function so that it works for both parts and assemblies, and then
  pass assemblies in.

Use MakeSketchTransform() to build the Transform object, then extract the rotation
  and translation information from it by using the .matrix() method. In the context
  of PartitionFace(), we can find the face that the ngon lives on, use some defaults
  to orient the sketch on that face, construct the Transform object, extract the
  rotation/translation information from the Transform object, and then use it to
  transform the points in the global coordinate system into the coordinate system
  of the sketch.

Take advantage of optional arguments and arbitrary number of function arguments.

Setup Linter.

Abaqus Feature objects are almost completely useless. When an Abaqus Feature object
  is created (via a call to PartitionFaceBySketch() for example) it's usually the
  case that some other object is created at the same time (for PartitionFaceBySketch(),
  at least one new Abaqus Face object is created and added to the appropriate
  repository of Abaqus Face objects). It's not uncommon to want to retrieve the 
  Abaqus Face object which was just created. However, it's not possible to do 
  this with just the Abaqus Feature object which was created alongside the 
  Abaqus Face object. The Abaqus Feature object has id and name data members,
  but these can only be used to lookup the Abaqus Feature object itself, not
  the underlying object.
A hack can be done where you monitor the sequence of interest (for example, the
  Abaqus FaceArray object associated with an Abaqus Part object) and if you know
  only a single new Abaqus object is created when the feature creation
  happens, you can extract the new Abaqus object by just extracting the
  last entry in the sequence. This forces you to assume that the new Abaqus object
  is always added as the last entry, and that only a single Abaqus object is
  created.

Tuples should be passed as arguments when the function will not need to modify.
  Passing a list to a function is dangerous because the function may modify the
  list.

Follow PEP8 style guidelines in codebase. I think that the most major change will
  be designating private attributes, functions, classes, and methods with a leading
  underscore. Also, in general it is recommended to expose attributes without
  complex accessor/mutator class methods. This idea might be incompatible with the
  notion of an abaqus shim and other techniques I have used. Note that non-public 
  class attributes are those that the programmer does not expect third-party users 
  to access. Therefore, a programmer might name a class attribute to designate it 
  as private, and then access it elsewhere inside the project. Also, the imports 
  should be structured accordingly.
