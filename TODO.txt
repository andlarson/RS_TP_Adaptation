


Short Term TODO.

1) Add support for variable mesh density. This should help with the shell-to-solid
      conversion failure, runtime issues, etc. It may still be necessary to do
      mesh -> geometry conversion outside Abaqus.

2) Update the tool pass comparison functions.

2) Add C++ support for defining some simple stress profiles.
   As part of this, account for the case when the user specifies a stress profile
      which is far from equilbirium. 

3) Create a small library of examples illustrating current functionality.

4) Add support for back calculating stress which caused a particular
      deformation.

5) If the user supplies their own estimated residual stress profile, it's necessary
      to allow the part, embued by this stress field which may not be in equilibirum, 
      to deform to achieve mechanical equilibrium. This is necessary only in the case
      when the user supplies an estimated stress profile.



Long Term TODO.

Experiments TODO:

    *** COMPARING BOOLEAN OPERATIONS AND ELEMENT DELETION ***
    Compare the deformation which results from geometry change to element deletion.



Thinking TODO:

    *** BCs IN SITUATIONS WITHOUT CLAMPING ***
    Think about Prof. Dick's claim: We need only a single BC constraining an element
      in order to prvent numerial errors from resulting in non-physical deformations.
      I agree with the claim. If the constrained element does not deform, then there
      is a slight amount of error introduced. This error is small if the element/region
      is small. If we restrict ourselves to situations where the clamps do not prevent
      the deformations due to residual stress, then I believe that the only purpose of
      boundary conditions is to prevent non-physical deformations due to numerical
      error. Therefore, constraining a single element is sufficient.



Code Organization / Structure TODO:

    *** MINGLING STRESS EQUILIBRATION AND MACHINING PROCEDURES ***
    It also feels brittle to intermingle the stress equilibration and the machining
      procedures. That is, material removal is really unrelated to a sometimes
      necessary stress equilibration step. Stress equilibration is sometimes necessary
      because the way that a stress field is represented doesn't exactly match
      reality. Material removal is a fundamental procedure which is required during
      the machining process.

    *** NAME CLEANING ***
    Figure out a way to make the naming cleaner. Specifically, we expect some names to
      be present and we always pick some particular names for use. Also, try to make
      some of my variable names in simulation.py more concise. The names currently
      make my eyes bleed.
        Partially done. Still don't like some of name passing is done in simulation.py. 
    Actually, just clean up how all the metadata is structured. Draw a picture!
    The new_model_names() function is overly complex. The general issue is that
       sometimes we have an MDB with a single model, and this model has already
       been created and has some components which are already named, and other 
       times we call this function before a model is being created.

    *** KEEPING TRACK OF CWD AND DIRECTORY CHANGES ***
    What is a general strategy for keeping track file directory modifications? Should
       no functions have any net effect on the CWD (i.e. they just change it when
       strictly necessary and then change it back before returning?), should each
       function be responsible for changing it as necessary and not change it back?
    In the current implementation, the commit_tool_pass() function implicitly assumes
       that the CWD is something and saves stuff in particular locations based on this
       assumption.

    *** MYPY STATIC ANALYSIS ***
    Get the MyPy static analysis up and running. Note that, for now, I'm only attempting
      to do static analysis when Python-native types are involved. There are objects
      native to Abaqus, numpy, etc. being passed around for which no type checking is
      done. I think there is hope of getting static analysis running for at least libraries
      like numpy. It might be worthwhile to build/contribute some basic stub files
      for Abaqus. Also, what should be done when a function takes in an  
      argument of a particular type, but the rest of the file doesn't need access to
      the file which contains the type? Does the type need to be absolutely referenced
      in the type line?

    *** FIXING IMPORTS ***
    Fix the way that imports are done so that main.py can be invoked from directories
      other than /software/ and without using its full path name.

    *** OPENING AND CLOSING MDB ***
    Use cleaner technique to deal with opening and closing an mdb. Figure out how to
      deal with exceptional conditions when an MDB is open and needs to be closed.
      Using a "with" statement might be very useful to do this.

    *** ISOLATION OF CALLS INTO ABAQUS API ***
    I've decided that all calls into the Abaqus API should be located in the
      abaqus_shim.py file. However, many of these functions return Abaqus-native
      objects, which are passed around in functions outside of abaqus_shim.py. Is
      this clean? Is the restriction of making Abaqus API calls in abaqus_shim.py
      really necessary?
        Solution: Eliminate the simple getter functions? 

    *** TUPLES VS. LISTS ***
    Tuples should be passed as arguments when the function will not need to modify.
      Passing a list to a function is dangerous because the function may modify the
      list.

    *** USING PEP8 CONVENTIONS ***
    Use the PEP8 conventions for naming externally visible vs internally visible
       stuff. In particular, a leading underscore should be used when necessary.    

    *** DEAL WITH EXCEPTIONS IN UNIFORM MANNER ***
    Don't catch all exceptions, only those that are expected (i.e. those of type
       AbaqusException). And when an exception is caught, emit information about
       it and re-raise it. 


Adding/Modifying Features TODO:

    *** TOOL PATH AND PART GEOMETRY DONT INTERSECT ***
    Deal with possibility that a tool path doesn't intersect the part geometry. If this
      is the case, the PartFromBooleanCut() method will throw an exception.

    *** MESHING ROBUSTNESS ***
    Make meshing more robust. Currently we just try some parameters (seed density,
      mesh shape, etc.) and if those parameters don't work we try some other
      parameters.
    Use a bounding splien based on the tool pass geometry instead of a bounding
       box. One potential approach is to trace the centroid of the tool along
       the spline, then simply using a larger radius for the bounding spline will 
       do the trick.    

    *** MAPPING ORPHAN MESH TO GEOEMTRY ***
    There is an awful lot of runtime spent mapping an orphan mesh to a new geometry.
      If we could instead chain simulations together within a single model, this could
      be avoided. To do this, it's necessary to somehow delete part regions/elements
      which live a prespecified locations in space across different steps in a simulation.
      For example, in step 1 we would want the elements that live in a particular
      region of space to be deactivated, some deformation would occur, in step 2 we 
      would want the elements that live in some other region of space to be deactivated,
      etc. 
    Potential element deletion techniques: 
        1) Contact interaction / damage model. 
        2) Simulation restart with new model change.
        3) Abaqus' Additive Manufacturing Process Simulation toolset (See Analysis 
           > Analysis Techniques > Additive Manufacturing Process Simulation, also 
           see User Subroutines > Toolpath-Mesh Intersection Utility Routines, and 
           see Analysis > Analysis Techniques > Special Purpose Techniques > Progressive 
           Element Activation. The most promising approach embedded in all of this 
           is to use Progressive Element Activation to do element DEactivation at 
           across multiple steps. We could define all elements in an initial mesh 
           as eligible for element deactivation and then, in the user subroutine 
           UEPACTIVATIONVOL, find all the elements in a particular tool path (this 
           might involve querying all elements), and setting their material volume
           fractions to 0). 
        4) Approximating element removal by making the element elasticity modulus 
           very small (this was Jan's suggestion, it doesn't fully make sense to me).
    Also might be possible to speed things up by using my current approach but
      doing things outside of Abaqus.

    *** VERTEX-BASED BOUNDARY CONDITIONS ***
    Add vertex-based boundary conditions.

    *** IMPROVING FACE PARTITIONING ROBUSTNESS ***
    Make the partition_face() function more robust. In particular, the find_face_ngon_lives_on()
       assumes that the user doesn't make some mistake and specify an ngon that
       doesn't actually live on any face!

    *** SUPPORTING USER DEFINED PARTS ***
    Support user-defined parts. These part geometries will come from in-machine scans.

    *** SUPPORTING REAL-LIFE MEASUREMENT DATA ***
    Add support for real-life measurement data.

    *** ACCOUNTING FOR STRESS PROFILES NOT IN EQUILBIRIUM ***
    Account for case when user-specified stress profile is far from equilibrium.
       This necessitates adding a simulation to find equilibrium. Probably requires
       updating list of assumptions.

    *** WORKAROUND FOR INTERACTIVE MODE ***
    Figure out a workaround so we don't have to run Abaqus in interactive mode.

    *** SPEEDING UP SIMULATION ARTIFACT CLEANUP ***
    Write routine to delete all directories created for some simulations to avoid
       manually deleting every time.

    *** SUPPORTING QUADRATIC SPLINES ***
    Can we support quadratic splines for toolpaths? 

    *** SUPPORTING ALTERNATIVE TOOL PASS ORIENTATIONS AND VARIETIES ***
    Can we support non-canonical tool pass orientations? 
    Can we support non-planar tool passes? Do we even want to?

    *** VIRTUAL TOPOLOGY ASSUMPTIONS ***
    If we allow a virtual topology to be created that causes faces to be merged,
       does this cause us to lose the geometric fidelity? How does the underlying
       representation of the part change when we do this?
